import datetime as dt
from collections.abc import Iterable
from typing import Any, Optional

from .models import QSO


def _fmt_date(d: Optional[dt.date]) -> Optional[str]:
    return d.strftime("%Y%m%d") if d else None


def _fmt_time(t: Optional[dt.time]) -> Optional[str]:
    if not t:
        return None
    # Ensure HHMMSS (pad seconds if needed)
    return t.strftime("%H%M%S")


def _tag(name: str, value: Any, type_code: Optional[str] = None) -> str:
    if value is None:
        return ""
    s = str(value)
    if s == "":
        return ""
    if type_code:
        return f"<{name}:{len(s)}:{type_code}>{s}"
    return f"<{name}:{len(s)}>{s}"


def qso_to_adif(q: QSO) -> str:
    parts: list[str] = []
    emitted: set[str] = set()

    def add(name: str, value: Any) -> None:
        tag = _tag(name, value)
        if tag:
            parts.append(tag)
            emitted.add(name.upper())
    # Derive SIG/MY_SIG for SOTA from dedicated refs if not explicitly provided.
    # For POTA, ADIF standard practice is to use SIG/MY_SIG with value 'POTA' and reference in SIG_INFO/MY_SIG_INFO.
    derived_sig = q.sig
    derived_sig_info = q.sig_info
    if not derived_sig and q.sota_ref:
        derived_sig = "SOTA"
    if not derived_sig_info and q.sota_ref:
        derived_sig_info = q.sota_ref
    derived_my_sig = q.my_sig
    derived_my_sig_info = q.my_sig_info
    if not derived_my_sig and q.my_sota_ref:
        derived_my_sig = "SOTA"
    if not derived_my_sig_info and q.my_sota_ref:
        derived_my_sig_info = q.my_sota_ref
    add("CALL", q.callsign)
    add("QSO_DATE", _fmt_date(q.qso_date))
    add("TIME_ON", _fmt_time(q.time_on))
    add("QSO_DATE_OFF", _fmt_date(q.qso_date_off))
    add("TIME_OFF", _fmt_time(q.time_off))
    add("BAND", q.band)
    add("FREQ", q.freq)
    add("BAND_RX", q.band_rx)
    add("FREQ_RX", q.freq_rx)
    add("MODE", q.mode)
    add("SUBMODE", q.submode)
    add("PROP_MODE", q.prop_mode)
    add("SAT_NAME", q.sat_name)
    add("STATION_CALLSIGN", q.station_callsign)
    add("OPERATOR", q.operator)
    add("RST_RCVD", q.rst_rcvd)
    add("RST_SENT", q.rst_sent)
    add("SRX", q.srx)
    add("SRX_STRING", q.srx_string)
    add("STX", q.stx)
    add("STX_STRING", q.stx_string)
    add("GRIDSQUARE", q.gridsquare)
    # Award/Program tags
    add("SIG", derived_sig)
    add("SIG_INFO", derived_sig_info)
    add("MY_SIG", derived_my_sig)
    add("MY_SIG_INFO", derived_my_sig_info)
    add("SOTA_REF", q.sota_ref)
    add("MY_SOTA_REF", q.my_sota_ref)
    add("NAME", q.name)
    add("TX_PWR", q.tx_pwr)
    add("COUNTRY", q.country)
    add("DXCC", q.dxcc)
    add("IOTA", q.iota)
    add("CQZ", q.cq_zone)
    add("ITUZ", q.itu_zone)
    add("MY_DXCC", q.my_dxcc)
    add("MY_STATE", q.my_state)
    add("MY_CNTY", q.my_cnty)
    add("MY_GRIDSQUARE", q.my_gridsquare)
    add("MY_VUCC_GRIDS", q.my_vucc_grids)
    add("MY_CQ_ZONE", q.my_cq_zone)
    add("MY_ITU_ZONE", q.my_itu_zone)
    add("MY_NAME", q.my_name)
    add("LOTW_QSL_RCVD", q.lotw_qsl_rcvd)
    add("LOTW_QSLRDATE", _fmt_date(q.lotw_qsl_rcvd_date))
    add("LOTW_QSL_SENT", q.lotw_qsl_sent)
    add("LOTW_QSLSDATE", _fmt_date(q.lotw_qsl_sent_date))
    add("NOTES", q.notes)
    # Append extras (skip tags already emitted above)
    if getattr(q, "extras", None) and q.extras.data:
        for key, value in q.extras.data.items():
            tag = str(key).upper()
            if tag in emitted:
                continue
            add(tag, value)

    return "".join(parts) + "<EOR>\n"


def queryset_to_adif(qs: Iterable[QSO]) -> str:
    header = (
        "Generated by LogHub <PROGRAMID:6>LogHub<PROGRAMVERSION:3>0.1\n"
        "<ADIF_VER:4>3.1\n<EOH>\n"
    )
    body = "".join(qso_to_adif(q) for q in qs)
    return header + body
