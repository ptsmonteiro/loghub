import datetime as dt
from collections.abc import Iterable
from typing import Any, Optional

from .models import QSO


def _fmt_date(d: Optional[dt.date]) -> Optional[str]:
    return d.strftime("%Y%m%d") if d else None


def _fmt_time(t: Optional[dt.time]) -> Optional[str]:
    if not t:
        return None
    # Ensure HHMMSS (pad seconds if needed)
    return t.strftime("%H%M%S")


def _tag(name: str, value: Any, type_code: Optional[str] = None) -> str:
    if value is None:
        return ""
    s = str(value)
    if s == "":
        return ""
    if type_code:
        return f"<{name}:{len(s)}:{type_code}>{s}"
    return f"<{name}:{len(s)}>{s}"


def qso_to_adif(q: QSO) -> str:
    parts: list[str] = []
    # Derive SIG/MY_SIG for SOTA from dedicated refs if not explicitly provided.
    # For POTA, ADIF standard practice is to use SIG/MY_SIG with value 'POTA' and reference in SIG_INFO/MY_SIG_INFO.
    derived_sig = q.sig
    derived_sig_info = q.sig_info
    if not derived_sig and q.sota_ref:
        derived_sig = "SOTA"
    if not derived_sig_info and q.sota_ref:
        derived_sig_info = q.sota_ref
    derived_my_sig = q.my_sig
    derived_my_sig_info = q.my_sig_info
    if not derived_my_sig and q.my_sota_ref:
        derived_my_sig = "SOTA"
    if not derived_my_sig_info and q.my_sota_ref:
        derived_my_sig_info = q.my_sota_ref
    parts.append(_tag("CALL", q.callsign))
    parts.append(_tag("QSO_DATE", _fmt_date(q.qso_date)))
    parts.append(_tag("TIME_ON", _fmt_time(q.time_on)))
    parts.append(_tag("QSO_DATE_OFF", _fmt_date(q.qso_date_off)))
    parts.append(_tag("TIME_OFF", _fmt_time(q.time_off)))
    parts.append(_tag("BAND", q.band))
    parts.append(_tag("FREQ", q.freq))
    parts.append(_tag("BAND_RX", q.band_rx))
    parts.append(_tag("FREQ_RX", q.freq_rx))
    parts.append(_tag("MODE", q.mode))
    parts.append(_tag("SUBMODE", q.submode))
    parts.append(_tag("PROP_MODE", q.prop_mode))
    parts.append(_tag("SAT_NAME", q.sat_name))
    parts.append(_tag("STATION_CALLSIGN", q.station_callsign))
    parts.append(_tag("OPERATOR", q.operator))
    parts.append(_tag("RST_RCVD", q.rst_rcvd))
    parts.append(_tag("RST_SENT", q.rst_sent))
    parts.append(_tag("SRX", q.srx))
    parts.append(_tag("SRX_STRING", q.srx_string))
    parts.append(_tag("STX", q.stx))
    parts.append(_tag("STX_STRING", q.stx_string))
    parts.append(_tag("GRIDSQUARE", q.gridsquare))
    # Award/Program tags
    parts.append(_tag("SIG", derived_sig))
    parts.append(_tag("SIG_INFO", derived_sig_info))
    parts.append(_tag("MY_SIG", derived_my_sig))
    parts.append(_tag("MY_SIG_INFO", derived_my_sig_info))
    parts.append(_tag("SOTA_REF", q.sota_ref))
    parts.append(_tag("MY_SOTA_REF", q.my_sota_ref))
    parts.append(_tag("NAME", q.name))
    parts.append(_tag("TX_PWR", q.tx_pwr))
    parts.append(_tag("COUNTRY", q.country))
    parts.append(_tag("DXCC", q.dxcc))
    parts.append(_tag("IOTA", q.iota))
    parts.append(_tag("CQZ", q.cq_zone))
    parts.append(_tag("ITUZ", q.itu_zone))
    parts.append(_tag("MY_DXCC", q.my_dxcc))
    parts.append(_tag("MY_STATE", q.my_state))
    parts.append(_tag("MY_CNTY", q.my_cnty))
    parts.append(_tag("MY_GRIDSQUARE", q.my_gridsquare))
    parts.append(_tag("MY_VUCC_GRIDS", q.my_vucc_grids))
    parts.append(_tag("MY_CQ_ZONE", q.my_cq_zone))
    parts.append(_tag("MY_ITU_ZONE", q.my_itu_zone))
    parts.append(_tag("MY_NAME", q.my_name))
    parts.append(_tag("LOTW_QSL_RCVD", q.lotw_qsl_rcvd))
    parts.append(_tag("LOTW_QSLRDATE", _fmt_date(q.lotw_qsl_rcvd_date)))
    parts.append(_tag("LOTW_QSL_SENT", q.lotw_qsl_sent))
    parts.append(_tag("LOTW_QSLSDATE", _fmt_date(q.lotw_qsl_sent_date)))
    parts.append(_tag("COMMENT", q.comment))
    return "".join(parts) + "<EOR>\n"


def queryset_to_adif(qs: Iterable[QSO]) -> str:
    header = (
        "Generated by LogHub <PROGRAMID:6>LogHub<PROGRAMVERSION:3>0.1\n"
        "<ADIF_VER:4>3.1\n<EOH>\n"
    )
    body = "".join(qso_to_adif(q) for q in qs)
    return header + body
